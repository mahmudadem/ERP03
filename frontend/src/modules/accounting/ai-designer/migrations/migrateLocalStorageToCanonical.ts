import { VoucherTypeDefinition } from '../../../../designer-engine/types/VoucherTypeDefinition';
import { FieldDefinition } from '../../../../designer-engine/types/FieldDefinition';

/**
 * One-Time Migration: AI Designer localStorage → Canonical Schema V2
 * 
 * ⚠️ CRITICAL MIGRATION RULES:
 * 1. All fields marked as NON-POSTING by default (isPosting = false, postingRole = null)
 * 2. Manual review required after migration
 * 3. SchemaVersion forced to 2
 * 4. Runs ONCE (idempotent guard)
 * 5. Backs up legacy data before migration
 * 
 * THIS MIGRATION DOES NOT INFER POSTING SEMANTICS.
 */

const LEGACY_KEY = 'cloudERP_vouchers';
const CANONICAL_KEY = 'cloudERP_vouchers_v2';
const MIGRATION_FLAG_KEY = 'cloudERP_migration_completed';

interface LegacyVoucherTypeConfig {
  id: string;
  name: string;
  prefix: string;
  isMultiLine: boolean;
  tableColumns?: string[];
  [key: string]: any;
}

export interface MigrationResult {
  success: boolean;
  migratedCount: number;
  skippedCount: number;
  errors: string[];
  backupKey?: string;
}

/**
 * Main migration function
 * Idempotent - can be called multiple times safely
 */
export function migrateLocalStorageToCanonical(): MigrationResult {
  const result: MigrationResult = {
    success: false,
    migratedCount: 0,
    skippedCount: 0,
    errors: []
  };

  try {
    // GUARD: Check if migration already completed
    if (isMigrationCompleted()) {
      result.success = true;
      result.skippedCount = -1; // Indicator that migration was skipped
      return result;
    }

    // STEP 1: Read legacy data
    const legacyData = readLegacyData();
    
    if (!legacyData || legacyData.length === 0) {
      markMigrationComplete();
      result.success = true;
      return result;
    }
    // STEP 2: Backup legacy data
    const backupKey = backupLegacyData(legacyData);
    result.backupKey = backupKey;
    // STEP 3: Migrate each definition
    const canonicalDefinitions: VoucherTypeDefinition[] = [];

    legacyData.forEach((legacy, index) => {
      try {
        const canonical = migrateLegacyToCanonical(legacy, index);
        canonicalDefinitions.push(canonical);
        result.migratedCount++;
        
        console.log(`[AI Designer Migration] Migrated: ${canonical.name} (${canonical.code})`);
      } catch (error: any) {
        result.errors.push(`Failed to migrate ${legacy.name}: ${error.message}`);
        result.skippedCount++;
        console.error(`[AI Designer Migration] Error migrating ${legacy.name}:`, error);
      }
    });

    // STEP 4: Save canonical definitions
    if (canonicalDefinitions.length > 0) {
      saveCanonicalDefinitions(canonicalDefinitions);
    }

    // STEP 5: Mark migration complete
    markMigrationComplete();

    // CRITICAL WARNING
    console.warn(
      '[AI Designer Migration] ⚠️ MANUAL REVIEW REQUIRED ⚠️\n' +
      'All fields marked as NON-POSTING (isPosting=false, postingRole=null).\n' +
      'Review each voucher definition and classify posting fields before use.'
    );

    result.success = true;
    return result;

  } catch (error: any) {
    result.errors.push(`Migration failed: ${error.message}`);
    console.error('[AI Designer Migration] Fatal error:', error);
    return result;
  }
}

/**
 * Convert legacy VoucherTypeConfig to canonical VoucherTypeDefinition
 */
function migrateLegacyToCanonical(
  legacy: LegacyVoucherTypeConfig,
  index: number
): VoucherTypeDefinition {
  // Generate safe code
  const code = generateSafeCode(legacy.name, legacy.prefix, index);

  // Build canonical definition
  const canonical: VoucherTypeDefinition = {
    // Identity
    id: legacy.id || generateId(),
    companyId: '', // Will be set when saved to backend
    name: legacy.name,
    code,
    module: 'ACCOUNTING',

    // Schema version (REQUIRED - Schema V2)
    schemaVersion: 2,

    // Fields (ALL MARKED AS NON-POSTING)
    headerFields: buildHeaderFieldsFromLegacy(legacy),
    tableColumns: buildTableColumnsFromLegacy(legacy),

    // Layout (empty - will be generated by UI)
    layout: {},

    // Posting roles (EMPTY - requires manual classification)
    requiredPostingRoles: undefined
  } as VoucherTypeDefinition;

  // Note: Migrated from AI Designer legacy format
  // All fields are non-posting by default
  // Manual review required for posting classification

  return canonical;
}

/**
 * Build header fields from legacy data
 * ALL FIELDS MARKED AS NON-POSTING
 */
function buildHeaderFieldsFromLegacy(legacy: LegacyVoucherTypeConfig): FieldDefinition[] {
  const fields: FieldDefinition[] = [];

  // Common voucher fields (ALL NON-POSTING)
  fields.push({
    id: 'date',
    name: 'date',
    label: 'Date',
    type: 'DATE',
    required: true,
    readOnly: false,
    isPosting: false, // NOT CLASSIFIED - requires review
    postingRole: null, // NOT CLASSIFIED - requires review
    schemaVersion: 2
  });

  fields.push({
    id: 'reference',
    name: 'reference',
    label: 'Reference',
    type: 'TEXT',
    required: false,
    readOnly: false,
    isPosting: false, // NOT CLASSIFIED - requires review
    postingRole: null, // NOT CLASSIFIED - requires review
    schemaVersion: 2
  });

  fields.push({
    id: 'description',
    name: 'description',
    label: 'Description',
    type: 'TEXTAREA',
    required: false,
    readOnly: false,
    isPosting: false, // NOT CLASSIFIED - requires review
    postingRole: null, // NOT CLASSIFIED - requires review
    schemaVersion: 2
  });

  return fields;
}

/**
 * Build table columns from legacy data
 */
function buildTableColumnsFromLegacy(
  legacy: LegacyVoucherTypeConfig
): VoucherTypeDefinition['tableColumns'] {
  if (!legacy.isMultiLine) {
    return []; // Single-line voucher, no table
  }

  // Default table columns for multi-line vouchers
  const defaultColumns = ['account', 'debit', 'credit', 'description'];
  const columns = legacy.tableColumns || defaultColumns;

  return columns.map(fieldId => ({
    fieldId,
    width: '25%'
  }));
}

/**
 * Generate safe voucher code
 */
function generateSafeCode(name: string, prefix: string, index: number): string {
  // Use prefix if available, otherwise generate from name
  if (prefix && prefix.trim()) {
    return prefix.replace(/[^A-Z0-9_]/g, '').toUpperCase();
  }

  // Generate from name (kebab-case to SCREAMING_SNAKE_CASE)
  const code = name
    .trim()
    .toUpperCase()
    .replace(/[^A-Z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '');

  // Ensure unique
  return `${code}_${index + 1}`;
}

/**
 * Generate unique ID
 */
function generateId(): string {
  return `migrated_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Check if migration already completed
 */
function isMigrationCompleted(): boolean {
  try {
    const flag = localStorage.getItem(MIGRATION_FLAG_KEY);
    return flag === 'true';
  } catch {
    return false;
  }
}

/**
 * Mark migration as complete
 */
function markMigrationComplete(): void {
  try {
    localStorage.setItem(MIGRATION_FLAG_KEY, 'true');
    localStorage.setItem(`${MIGRATION_FLAG_KEY}_timestamp`, new Date().toISOString());
  } catch (error) {
    console.error('[AI Designer Migration] Failed to mark migration complete:', error);
  }
}

/**
 * Read legacy data from localStorage
 */
function readLegacyData(): LegacyVoucherTypeConfig[] {
  try {
    const data = localStorage.getItem(LEGACY_KEY);
    if (!data) return [];
    
    const parsed = JSON.parse(data);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.error('[AI Designer Migration] Failed to read legacy data:', error);
    return [];
  }
}

/**
 * Backup legacy data
 */
function backupLegacyData(data: LegacyVoucherTypeConfig[]): string {
  const timestamp = Date.now();
  const backupKey = `${LEGACY_KEY}_backup_${timestamp}`;
  
  try {
    localStorage.setItem(backupKey, JSON.stringify(data));
    return backupKey;
  } catch (error) {
    console.error('[AI Designer Migration] Failed to backup legacy data:', error);
    throw error;
  }
}

/**
 * Save canonical definitions
 */
function saveCanonicalDefinitions(definitions: VoucherTypeDefinition[]): void {
  try {
    localStorage.setItem(CANONICAL_KEY, JSON.stringify(definitions));
  } catch (error) {
    console.error('[AI Designer Migration] Failed to save canonical definitions:', error);
    throw error;
  }
}

/**
 * Load canonical definitions
 */
export function loadCanonicalDefinitions(): VoucherTypeDefinition[] {
  try {
    const data = localStorage.getItem(CANONICAL_KEY);
    if (!data) return [];
    
    const parsed = JSON.parse(data);
    if (!Array.isArray(parsed)) return [];

    // Validate each definition
    return parsed.filter(def => {
      if (def.schemaVersion !== 2) {
        console.warn(`[AI Designer] Skipping definition with schema version ${def.schemaVersion}`);
        return false;
      }
      return true;
    });
  } catch (error) {
    console.error('[AI Designer] Failed to load canonical definitions:', error);
    return [];
  }
}

/**
 * Save canonical definitions (with validation)
 */
export function saveCanonicalDefinitionsValidated(definitions: VoucherTypeDefinition[]): void {
  // Validate all definitions are Schema V2
  definitions.forEach(def => {
    if (def.schemaVersion !== 2) {
      throw new Error(`Cannot save definition "${def.name}": schemaVersion must be 2`);
    }
  });

  try {
    localStorage.setItem(CANONICAL_KEY, JSON.stringify(definitions));
  } catch (error) {
    console.error('[AI Designer] Failed to save:', error);
    throw error;
  }
}
